<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprBlob</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize Blob
image_speed = 0.5;
blob_stats = ds_map_create();
ds_map_add(blob_stats, "food_requirement", 1);  //The number of food needed to stay alive. Each additional food item will = 1 offspring.
ds_map_add(blob_stats, "speed", 6);         //Initialize blob's speed trait. Pixels/step.
ds_map_add(blob_stats, "sight", 32);        //Sight range in pixels (for seeking food and avoiding carnivores)
ds_map_add(blob_stats, "veer_distance", 64);//How soon before reaching the target coordinates the blob is seeking will the blob veer away
ds_map_add(blob_stats, "longest_seek_distance", 128);   //The furthest distance the blob will set its seeking coordinates
ds_map_add(blob_stats, "instinct", 0);      //From 0 to 1, the percentage affects how likely movement will random (0), and how much will be determined by what it sees (food, enemy, perimiter)
ds_map_add(blob_stats, "size", 1);          //How big is the blob
ds_map_add(blob_stats, "offspring_food_ratio", 0.5);    //The ratio of offspring to food consumed by the blob

blob_food_count = 0;    //The blob starts out with an empty tummy
blob_awake = false;     //Initialize the blob to be asleep.
blob_seek_x = x;        //The coordinates towards which the blob will move, until getting within veering distance, then the blob will choose a new direction to go to
blob_seek_y = y;
mutation_percent_change = 5;//Can randomly change all mutatable stats by x% each generation

/*blob_food_requirement = 1;  
blob_food_count = 0;    
blob_speed = 6;     
blob_sight = 32;    
veer_distance = 64;//Range at which to choose a new direction
longest_seek_distance = 128;//The furthest away a blob will set its seeking coordinates
blob_offspring_food_ratio = 0.5;    //The offspring/food ratio
*/

/*
For future reference:
Everything should have a cost, and things should have opposites. For example, to increase size, stealth must decrease because they have an opposite relationship.
//blob_percent_herbivore = 100;
//blob_percent_carnivore = 0;
//blob_percent_scavenger = 0;
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Blob Moving
var blob_food_requirement = ds_map_find_value(blob_stats, "food_requirement");
var blob_speed = ds_map_find_value(blob_stats, "speed");
var blob_sight = ds_map_find_value(blob_stats, "sight");
var veer_distance = ds_map_find_value(blob_stats, "veer_distance");
var longest_seek_distance = ds_map_find_value(blob_stats, "longest_seek_distance");
//var blob_offspring_food_ratio = ds_map_find_value(blob_stats, "offspring_food_ratio");

//Test algorithm. move until full, then move to nearest place off field
if (!blob_awake)    //If the blob isn't awake, we don't want it moving
{
    blob_seek_x = x;//Reset the coordinates which the blob seeks to follow to the blob's current coordinates
    blob_seek_y = y;
}
else if (distance_to_point(blob_seek_x, blob_seek_y) &lt; veer_distance)   //If the blob is within veering range of the coordinates they were seeking
{
    var valid_point_found = false;  //we haven't found valid coordinates to seek yet because we haven't done the calculation to find new coordinates yet
    var max_tries = 100;    //Just in case, we will limit the tries to find new valid coordinates to 100.
    var tries = 0;  //We haven't made any tries to find new coordinates to seek yet
    while (!valid_point_found &amp;&amp; tries &lt; max_tries) //While we haven't found valid coordinates to seek yet, and we haven't reached our max number of tries yet
    {
        var theta = random_range(0,360);    //
        var min_dist = (longest_seek_distance - veer_distance)/2+veer_distance;
        var dist = random_range(min_dist, longest_seek_distance);
        var dx = lengthdir_x(dist, theta);
        var dy = lengthdir_y(dist, theta);
        blob_seek_x = x+dx;
        blob_seek_y = y+dy;
        valid_point_found = true;   //Assume the point we found was valid (optimistic)
        if (blob_food_count &lt; blob_food_requirement)    //But if the blob's belly isn't full yet
        {
            if (blob_seek_x &gt; getFieldRightBound()      //and the blob tries to leave
                || blob_seek_x &lt; getFieldLeftBound()
                || blob_seek_y &gt; getFieldBottomBound()
                || blob_seek_y &lt; getFieldTopBound())
            {
                valid_point_found = false;  //Then try again to seek a different point
            }
        }
        tries++;
    }
}
else
{
    move_towards_point(blob_seek_x, blob_seek_y, blob_speed);
    if (blob_food_count &gt; 0 &amp;&amp; (x &gt; getFieldRightBound()
                || x &lt; getFieldLeftBound()
                || y &gt; getFieldBottomBound()
                || y &lt; getFieldTopBound()))
    {
        speed = 0;
        blob_seek_x = x;
        blob_seek_y = y;
        blob_awake = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objGreens">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Eat Greens
with (other)
{
    instance_destroy();
}
blob_food_count++;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw self and debug features
draw_sprite(sprite_index, image_index, x, y);
if (DEBUG_BLOBS)
{
    var blob_food_requirement = ds_map_find_value(blob_stats, "food_requirement");
    var blob_speed = ds_map_find_value(blob_stats, "speed");
    var blob_sight = ds_map_find_value(blob_stats, "sight");
    var veer_distance = ds_map_find_value(blob_stats, "veer_distance");
    var longest_seek_distance = ds_map_find_value(blob_stats, "longest_seek_distance");
    var ccc = draw_get_color();
    draw_set_color(c_red);
    draw_arrow(x, y, blob_seek_x, blob_seek_y, 4);
    draw_circle(x, y, veer_distance, 1);
    draw_set_color(c_green);
    var str_a = "zzz";
    if (blob_awake) str_a = ":)";
    draw_text(x, y, string(blob_food_count) + ", " + str_a);
    draw_set_color(ccc);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
